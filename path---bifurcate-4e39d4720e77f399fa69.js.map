{"version":3,"sources":["webpack:///path---bifurcate-4e39d4720e77f399fa69.js","webpack:///./.cache/json/bifurcate.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/bifurcate.json","module","exports","data","markdownRemark","html","timeToRead","frontmatter","date","path","tags","title","responsiveImage","responsiveSizes","aspectRatio","base64","src","srcSet","sizes","pathContext","prev","next","id","fileAbsolutePath","summary"],"mappings":"AAAAA,cAAc,KAERC,mEACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,4hPAAAC,WAAA,EAAAC,aAAikPC,KAAA,gBAAAC,KAAA,aAAAC,MAAA,sDAAAC,MAAA,cAA8HC,iBAAoBC,iBAAmBC,YAAA,mBAAAC,OAAA,80BAA2DC,IAAA,0DAAAC,OAAA,6XAAAC,MAAA,qCAA+yCC,aAAgBC,MAAA,EAAAC,MAAqBhB,KAAA,+pJAAAiB,GAAA,8HAAAC,iBAAA,2FAAAjB,WAAA,EAAAC,aAAq7JC,KAAA,4BAAAC,KAAA,WAAAC,MAAA,0BAAAC,MAAA,UAAAa,QAAA","file":"path---bifurcate-4e39d4720e77f399fa69.js","sourcesContent":["webpackJsonp([23],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/bifurcate.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>Over the past year, whilst on placement at Lilly, my main focus was setting up on-premise platform-as-a-service (OpenShift). I worked as part of a small team on this, with a few people in the US and a few in the UK.</p>\\n<p>One of the tools we created was a metrics dashboard with charts showing usage information about the platform. For MVP we built this as a Django monolith, which was fine to get something out the door, but it was difficult to coordinate across timezones, since half the team was in the UK and half in the US. Our skillsets were also segregated, with the experienced Django developers sitting in the US whereas the UK team members were more comfortable with Node.js.</p>\\n<p>I identified that a microservices architecture would be a better fit for this project so each subteam could develop more independently. We also liked the idea of some of the other advantages of a service-oriented architecture, like independent release schedules and the ability to choose the most suitable stack for each part of the application.</p>\\n<h2>The app</h2>\\n<h3>MVP 1</h3>\\n<p>The Django MVP of our app was pretty basic, hitting the OpenShift API and parsing that data on every page load. We passed that parsed data into the HTML templates and rendered some tables and charts. This did satisfy the baseline requirements of showing management and ourselves the customer uptake of OpenShift, but it had some flaws, first and foremost, page load time. As more customers started checking the dashboard, we also put strain on the OpenShift API, particularly in our Proof-of-Concept environment, where resources are limited.</p>\\n<h3>MVP 2</h3>\\n<p>Since a lot of the data parsing logic was already implemented in Python, we decided to keep a Django-based backend, but convert it to a RESTful API. During this period we learned a lot about the tradeoffs during API development, and why an API-centric approach to software development can be so powerful in enabling internal collaboration.</p>\\n<p>See Jeff Bezos' 'API Mandate' at Amazon in the early 2000's  - he mandated that all employees must develop services in order to share information between teams, i.e. the only way to get access to other internal data was through an API. This edict was transformational to the way Amazon employees worked, and the way the company was structured internally, arguably a big factor in enabling Amazon to go from an online bookstore to the enormous e-commerce and cloud computing platform it is today.</p>\\n<p>For the frontend I chose to go with React, hosted on a Node server. These were technologies I had a fair bit of previous experience with, and the dashboard was a good fit for the component-oriented architecture of React app, since we had a similar dataset for all 3 of our OpenShift environments, hence often 3 charts displaying the same kind of data.</p>\\n<h2>Wrangling Django</h2>\\n<p>For MVP2, converting the backend to return JSON wasn't crazily difficult. We already passed some data into our templates, so we could get a basic response going by returning a <code>django.http JsonResponse</code> instead of <code>render</code>ing a template. Of course this didn't give us a true RESTful API, but for a couple of <code>GET</code> endpoints it did the job.</p>\\n<p>One issue I ran into was attempting to serialize our Django objects - when passing an object into a template file you can use Django Classes just fine, but as soon as I tried to serialize these into JSON up popped a whole bunch of errors. Fortunately, out of the box Django provides serialization into JSON as long as you use a <code>Model</code> rather than a <code>Class</code>. Converting our classes to models was relatively straightforward and essentially required me to specify some detail about each field like datatype, length, etc..</p>\\n<p>Later, as we built out our API interfacing between OpenShift and our frontend, and we needed more endpoints, especially <code>POST</code>/<code>PUT</code>, we moved to use <a href=\\\"http://www.django-rest-framework.org/\\\">Django REST Framework</a> (DRF). DRF is actually a really nice tool, and gives you a lot of features 'for free' as you build an API, like making your API browsable, and easy integration with OAuth. Next time I build an API I'd probably check out something like <a href=\\\"https://swagger.io/\\\">Swagger</a>, or explore using a statically typed or functional language like Go or Elixir in the backend.</p>\\n<h2>Juggling Javascript</h2>\\n<p>I built the frontend in React, using the <a href=\\\"https://react.semantic-ui.com/introduction\\\">semantic-ui-react</a> framework, and <a href=\\\"https://github.com/reactjs/react-chartjs\\\">react-chartjs</a>. These frameworks made it easy to create a responsive site, and I created some nice pure chart components. The one hurdle I had to watch out for was to get the data from our API in the correct React lifecycle method - I ended up using <code>fetch</code> inside <code>componentDidMount</code>. Sadly Internet Explorer is the default browser at work, so to support that I had to import the <a href=\\\"https://www.npmjs.com/package/whatwg-fetch\\\">whatwg-fetch</a> polyfill.</p>\\n<h3>Caching</h3>\\n<p>One of the main drawbacks of MVP1 was the page load time, since we fetched data from the OpenShift API on every page load. To try and address this, I decided to add some caching to our app, which happened at a few different layers. I tackled the following bullet points one-by-one, benchmarking page load times at each step.</p>\\n<ul>\\n<li>Since I'm most familiar with Node, I wrote a short cron job using <a href=\\\"https://www.npmjs.com/package/node-cron\\\">node-cron</a>, which regularly copied the OpenShift API responses verbatim into redis. Of course I had to edit our backend to consume the cache instead of getting data from OpenShift directly, using <a href=\\\"https://github.com/andymccurdy/redis-py\\\">redis-py</a>.</li>\\n<li>This sped up page load times a fair bit, but the data parsing step was still happening on every refresh, since only the raw OpenShift API responses were in redis, not the collated data. So, I added to my cron job - I stored <em>our</em> Django API responses in redis too. After editing the backend again to retrieve the <em>parsed data</em> from redis where possible, this meant page load times were considerably decreased.</li>\\n<li>The one 'gotcha' here is that if our API returned its values from the redis cache, how would we update the cache with new values? I set the redis expiry time to be a little lower than the cron frequency, which meant that new results would be computed every time the cron job ran.</li>\\n<li>Of course, if redis was down, would that bring down our entire API? No, because if a key did not exist (it had expired or redis was down), I would fall back to parsing the data and/or getting data directly from OpenShift.</li>\\n</ul>\\n<h2>Further Improvements and takeaways</h2>\\n<p>As mentioned previously, we later moved our Django API over to Django Rest Framework, which gave us a lot more reliability and the ability to plug in a Postgres database, which meant we could store historical data too.</p>\\n<p>The best part about this migration to DRF was that we didn't have to change the frontend - perhaps we changed what endpoint we hit via an environment variable, but we could pretty much leave the frontend alone since it was a separate service.</p>\\n<p>Overall this was a fantastic project which really hammered home the value of service oriented architecture and made me realise that designing an API is harder than it looks! I've been using the GitHub GraphQL API in another project, which is a lot of fun and seems especially powerful for mobile apps.</p>\",\"timeToRead\":5,\"frontmatter\":{\"date\":\"June 15, 2017\",\"path\":\"/bifurcate\",\"tags\":[\"lilly\",\"javascript\",\"react\",\"python\",\"django\",\"API\"],\"title\":\"Bifurcate\"}},\"responsiveImage\":{\"responsiveSizes\":{\"aspectRatio\":1.5003348961821836,\"base64\":\"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMFBP/EABUBAQEAAAAAAAAAAAAAAAAAAAEA/9oADAMBAAIQAxAAAAF9KayKBnE//8QAHRAAAQIHAAAAAAAAAAAAAAAAAwECAAQQERITIf/aAAgBAQABBQKSfcWSUGNutourH//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABwQAAICAgMAAAAAAAAAAAAAAAABAhEQEiExYf/aAAgBAQAGPwJ7Suhe4dcEXsztn//EABsQAQACAwEBAAAAAAAAAAAAAAEAESExQWHB/9oACAEBAAE/IVSlneQuy8R3uUo54sgFpRvcDf0n/9oADAMBAAIAAwAAABBI3//EABYRAQEBAAAAAAAAAAAAAAAAAAABEf/aAAgBAwEBPxCVr//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB4QAQEAAgEFAQAAAAAAAAAAAAERAGEhMVFxgaGx/9oACAEBAAE/ECIAQdRN7yNk6fLthXhHrDKFsAtnOzEvEgifmWfmjP/Z\",\"src\":\"/blog/static/2eefd4aa314e4d47dc4b6bf9819cd773-7da9d.jpg\",\"srcSet\":\"/blog/static/2eefd4aa314e4d47dc4b6bf9819cd773-e49f3.jpg 200w,\\n/blog/static/2eefd4aa314e4d47dc4b6bf9819cd773-5758d.jpg 400w,\\n/blog/static/2eefd4aa314e4d47dc4b6bf9819cd773-7da9d.jpg 800w,\\n/blog/static/2eefd4aa314e4d47dc4b6bf9819cd773-936f0.jpg 1200w,\\n/blog/static/2eefd4aa314e4d47dc4b6bf9819cd773-13920.jpg 1600w,\\n/blog/static/2eefd4aa314e4d47dc4b6bf9819cd773-500df.jpg 2240w\",\"sizes\":\"(max-width: 800px) 100vw, 800px\"}}},\"pathContext\":{\"prev\":false,\"next\":{\"html\":\"<h2>The Competition</h2>\\n<p>The Microsoft Imagine Cup is a competition for students ... Microsoft describes it better than I can:</p>\\n<blockquote>\\n<p>Imagine Cup is a global competition that empowers the next generation of computer science students to team up and use their creativity, passion and knowledge of technology to create applications that shape how we live, work and play. Every year tens of thousands of students from across the globe compete for cash, travel and prizes and for the honor of taking home the Imagine Cup!</p>\\n</blockquote>\\n<p>My flatmate, Wilson, found out about the competition - after he told me and one of his friends from Uni, Sam, we decided to give it a go. Little did we know we'd make it all the way to the national finals!</p>\\n<h2>Our Product</h2>\\n<p>After an extensive brainstorming session resulting in many crumpled pieces of paper, we drew inspiration from the then-recently released Wetherspoons app. Their app allows you to order and pay for food and drink from your table - no more waiting at the bar!</p>\\n<p>We loved the convenience and thought it'd be great to have this ability at every restaurant or bar. Some market research showed that while some large chains (McDonald's, Wagamamas) recently released apps with similar functionality, no solution existed for independent businesses, or even small to medium size chains.</p>\\n<p>So, we chose to create a customer purchase and ordering platform for independent restaurants and bars:</p>\\n<p>Onboarding businesses had to be as streamlined as possible, so we created a simple sign-up form, followed by a drag-and-drop web interface for the owner to create their menu. Each menu has a unique QR code for the owner to display e.g. on tables. The owner can log back in at any time to update prices or availability of menu items, which will be instantly reflected in the menu the customer sees.</p>\\n<p>The customer scans the QR (or enters the menu ID on our website) and is taken directly to a mobile-optimized webapp where they can see what's on offer and add items to their basket. The customer can then submit their order and pay through PayPal - performing the entire transaction without downloading an app or creating an account!</p>\\n<p>Once confirmed, the order goes straight through to a touchscreen (which could be a cheap android tablet) in the kitchen/bar for staff to fulfill. Staff can tap the screen to check orders off once they're completed and keep track of the status.</p>\\n<h3>Advantages</h3>\\n<ul>\\n<li>The customer receives their order without leaving their seat!</li>\\n<li>Restaurant can reduce front of house staff</li>\\n<li>Bar can reduce average wait time</li>\\n<li>Front of house staff can focus on what really matters - providing an exceptional customer experience</li>\\n</ul>\\n<h2>The Tech</h2>\\n<p>The frontend of the app was written in Node.js and Express. We used these technologies since we all had experience with them - for this project we decided we should focus on delivering a great product, and there was still plenty to learn since we were new to the Azure platform.</p>\\n<p>We got Azure credit as part of the competition, so it made sense to use Microsoft's platform to host our Node app - we also used an MSSQL database and Azure Redis for caching. I quite enjoyed using Azure - it's becoming difficult to see the differentiation between GCP, AWS, and Azure for basic hosting like this. I think to choose between platforms I'd probably consider pricing first, and for simplicity go with the platform on which I was already using less common functionality like AWS Lambda.</p>\\n<h2>The UK finals</h2>\\n<p>We submitted a short video pitch and our business plan. After a couple of weeks we got a very exciting email: we were through to the UK finals! The final took place at Microsoft's London offices, where we were given the opportunity to present to such dignitaries as the CTO of Microsoft Accelerator, their Principal Tech Evangelist, and the Director of Azure for Research.</p>\\n<p>It was an amazing day, with sessions on entrepreneurship and tons of advice on how to start and scale a business. We got great feedback on our product - the judges highlighted our customer focus and real potential to disrupt the hospitality industry. Unfortunately we didn't make it through to the next stage of the competition, but I had a great time working with Wilson and Sam, and we all learned a lot technically, as well as about creating a startup.</p>\\n<p>Some feedback from the judges:</p>\\n<ul>\\n<li>\\\"Could definitely see this taking off\\\"</li>\\n<li>\\\"Slick presentation\\\"</li>\\n<li>\\\"You've clearly identified and addressed a real problem in this market\\\"</li>\\n<li>\\\"Solid validation from external stakeholders\\\"</li>\\n</ul>\",\"id\":\"/Users/matt/Documents/code/gatsby-blog-starter-kit/src/pages/2017-05-02-imagine/index.md absPath of file >>> MarkdownRemark\",\"fileAbsolutePath\":\"/Users/matt/Documents/code/gatsby-blog-starter-kit/src/pages/2017-05-02-imagine/index.md\",\"timeToRead\":3,\"frontmatter\":{\"date\":\"2017-05-02T11:27:49+01:00\",\"path\":\"/imagine\",\"tags\":[\"hackathon\",\"javascript\"],\"title\":\"Imagine\",\"summary\":\"Competing in the Microsoft Imagine Cup\"}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---bifurcate-4e39d4720e77f399fa69.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>Over the past year, whilst on placement at Lilly, my main focus was setting up on-premise platform-as-a-service (OpenShift). I worked as part of a small team on this, with a few people in the US and a few in the UK.</p>\\n<p>One of the tools we created was a metrics dashboard with charts showing usage information about the platform. For MVP we built this as a Django monolith, which was fine to get something out the door, but it was difficult to coordinate across timezones, since half the team was in the UK and half in the US. Our skillsets were also segregated, with the experienced Django developers sitting in the US whereas the UK team members were more comfortable with Node.js.</p>\\n<p>I identified that a microservices architecture would be a better fit for this project so each subteam could develop more independently. We also liked the idea of some of the other advantages of a service-oriented architecture, like independent release schedules and the ability to choose the most suitable stack for each part of the application.</p>\\n<h2>The app</h2>\\n<h3>MVP 1</h3>\\n<p>The Django MVP of our app was pretty basic, hitting the OpenShift API and parsing that data on every page load. We passed that parsed data into the HTML templates and rendered some tables and charts. This did satisfy the baseline requirements of showing management and ourselves the customer uptake of OpenShift, but it had some flaws, first and foremost, page load time. As more customers started checking the dashboard, we also put strain on the OpenShift API, particularly in our Proof-of-Concept environment, where resources are limited.</p>\\n<h3>MVP 2</h3>\\n<p>Since a lot of the data parsing logic was already implemented in Python, we decided to keep a Django-based backend, but convert it to a RESTful API. During this period we learned a lot about the tradeoffs during API development, and why an API-centric approach to software development can be so powerful in enabling internal collaboration.</p>\\n<p>See Jeff Bezos' 'API Mandate' at Amazon in the early 2000's  - he mandated that all employees must develop services in order to share information between teams, i.e. the only way to get access to other internal data was through an API. This edict was transformational to the way Amazon employees worked, and the way the company was structured internally, arguably a big factor in enabling Amazon to go from an online bookstore to the enormous e-commerce and cloud computing platform it is today.</p>\\n<p>For the frontend I chose to go with React, hosted on a Node server. These were technologies I had a fair bit of previous experience with, and the dashboard was a good fit for the component-oriented architecture of React app, since we had a similar dataset for all 3 of our OpenShift environments, hence often 3 charts displaying the same kind of data.</p>\\n<h2>Wrangling Django</h2>\\n<p>For MVP2, converting the backend to return JSON wasn't crazily difficult. We already passed some data into our templates, so we could get a basic response going by returning a <code>django.http JsonResponse</code> instead of <code>render</code>ing a template. Of course this didn't give us a true RESTful API, but for a couple of <code>GET</code> endpoints it did the job.</p>\\n<p>One issue I ran into was attempting to serialize our Django objects - when passing an object into a template file you can use Django Classes just fine, but as soon as I tried to serialize these into JSON up popped a whole bunch of errors. Fortunately, out of the box Django provides serialization into JSON as long as you use a <code>Model</code> rather than a <code>Class</code>. Converting our classes to models was relatively straightforward and essentially required me to specify some detail about each field like datatype, length, etc..</p>\\n<p>Later, as we built out our API interfacing between OpenShift and our frontend, and we needed more endpoints, especially <code>POST</code>/<code>PUT</code>, we moved to use <a href=\\\"http://www.django-rest-framework.org/\\\">Django REST Framework</a> (DRF). DRF is actually a really nice tool, and gives you a lot of features 'for free' as you build an API, like making your API browsable, and easy integration with OAuth. Next time I build an API I'd probably check out something like <a href=\\\"https://swagger.io/\\\">Swagger</a>, or explore using a statically typed or functional language like Go or Elixir in the backend.</p>\\n<h2>Juggling Javascript</h2>\\n<p>I built the frontend in React, using the <a href=\\\"https://react.semantic-ui.com/introduction\\\">semantic-ui-react</a> framework, and <a href=\\\"https://github.com/reactjs/react-chartjs\\\">react-chartjs</a>. These frameworks made it easy to create a responsive site, and I created some nice pure chart components. The one hurdle I had to watch out for was to get the data from our API in the correct React lifecycle method - I ended up using <code>fetch</code> inside <code>componentDidMount</code>. Sadly Internet Explorer is the default browser at work, so to support that I had to import the <a href=\\\"https://www.npmjs.com/package/whatwg-fetch\\\">whatwg-fetch</a> polyfill.</p>\\n<h3>Caching</h3>\\n<p>One of the main drawbacks of MVP1 was the page load time, since we fetched data from the OpenShift API on every page load. To try and address this, I decided to add some caching to our app, which happened at a few different layers. I tackled the following bullet points one-by-one, benchmarking page load times at each step.</p>\\n<ul>\\n<li>Since I'm most familiar with Node, I wrote a short cron job using <a href=\\\"https://www.npmjs.com/package/node-cron\\\">node-cron</a>, which regularly copied the OpenShift API responses verbatim into redis. Of course I had to edit our backend to consume the cache instead of getting data from OpenShift directly, using <a href=\\\"https://github.com/andymccurdy/redis-py\\\">redis-py</a>.</li>\\n<li>This sped up page load times a fair bit, but the data parsing step was still happening on every refresh, since only the raw OpenShift API responses were in redis, not the collated data. So, I added to my cron job - I stored <em>our</em> Django API responses in redis too. After editing the backend again to retrieve the <em>parsed data</em> from redis where possible, this meant page load times were considerably decreased.</li>\\n<li>The one 'gotcha' here is that if our API returned its values from the redis cache, how would we update the cache with new values? I set the redis expiry time to be a little lower than the cron frequency, which meant that new results would be computed every time the cron job ran.</li>\\n<li>Of course, if redis was down, would that bring down our entire API? No, because if a key did not exist (it had expired or redis was down), I would fall back to parsing the data and/or getting data directly from OpenShift.</li>\\n</ul>\\n<h2>Further Improvements and takeaways</h2>\\n<p>As mentioned previously, we later moved our Django API over to Django Rest Framework, which gave us a lot more reliability and the ability to plug in a Postgres database, which meant we could store historical data too.</p>\\n<p>The best part about this migration to DRF was that we didn't have to change the frontend - perhaps we changed what endpoint we hit via an environment variable, but we could pretty much leave the frontend alone since it was a separate service.</p>\\n<p>Overall this was a fantastic project which really hammered home the value of service oriented architecture and made me realise that designing an API is harder than it looks! I've been using the GitHub GraphQL API in another project, which is a lot of fun and seems especially powerful for mobile apps.</p>\",\"timeToRead\":5,\"frontmatter\":{\"date\":\"June 15, 2017\",\"path\":\"/bifurcate\",\"tags\":[\"lilly\",\"javascript\",\"react\",\"python\",\"django\",\"API\"],\"title\":\"Bifurcate\"}},\"responsiveImage\":{\"responsiveSizes\":{\"aspectRatio\":1.5003348961821836,\"base64\":\"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMFBP/EABUBAQEAAAAAAAAAAAAAAAAAAAEA/9oADAMBAAIQAxAAAAF9KayKBnE//8QAHRAAAQIHAAAAAAAAAAAAAAAAAwECAAQQERITIf/aAAgBAQABBQKSfcWSUGNutourH//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABwQAAICAgMAAAAAAAAAAAAAAAABAhEQEiExYf/aAAgBAQAGPwJ7Suhe4dcEXsztn//EABsQAQACAwEBAAAAAAAAAAAAAAEAESExQWHB/9oACAEBAAE/IVSlneQuy8R3uUo54sgFpRvcDf0n/9oADAMBAAIAAwAAABBI3//EABYRAQEBAAAAAAAAAAAAAAAAAAABEf/aAAgBAwEBPxCVr//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB4QAQEAAgEFAQAAAAAAAAAAAAERAGEhMVFxgaGx/9oACAEBAAE/ECIAQdRN7yNk6fLthXhHrDKFsAtnOzEvEgifmWfmjP/Z\",\"src\":\"/blog/static/2eefd4aa314e4d47dc4b6bf9819cd773-7da9d.jpg\",\"srcSet\":\"/blog/static/2eefd4aa314e4d47dc4b6bf9819cd773-e49f3.jpg 200w,\\n/blog/static/2eefd4aa314e4d47dc4b6bf9819cd773-5758d.jpg 400w,\\n/blog/static/2eefd4aa314e4d47dc4b6bf9819cd773-7da9d.jpg 800w,\\n/blog/static/2eefd4aa314e4d47dc4b6bf9819cd773-936f0.jpg 1200w,\\n/blog/static/2eefd4aa314e4d47dc4b6bf9819cd773-13920.jpg 1600w,\\n/blog/static/2eefd4aa314e4d47dc4b6bf9819cd773-500df.jpg 2240w\",\"sizes\":\"(max-width: 800px) 100vw, 800px\"}}},\"pathContext\":{\"prev\":false,\"next\":{\"html\":\"<h2>The Competition</h2>\\n<p>The Microsoft Imagine Cup is a competition for students ... Microsoft describes it better than I can:</p>\\n<blockquote>\\n<p>Imagine Cup is a global competition that empowers the next generation of computer science students to team up and use their creativity, passion and knowledge of technology to create applications that shape how we live, work and play. Every year tens of thousands of students from across the globe compete for cash, travel and prizes and for the honor of taking home the Imagine Cup!</p>\\n</blockquote>\\n<p>My flatmate, Wilson, found out about the competition - after he told me and one of his friends from Uni, Sam, we decided to give it a go. Little did we know we'd make it all the way to the national finals!</p>\\n<h2>Our Product</h2>\\n<p>After an extensive brainstorming session resulting in many crumpled pieces of paper, we drew inspiration from the then-recently released Wetherspoons app. Their app allows you to order and pay for food and drink from your table - no more waiting at the bar!</p>\\n<p>We loved the convenience and thought it'd be great to have this ability at every restaurant or bar. Some market research showed that while some large chains (McDonald's, Wagamamas) recently released apps with similar functionality, no solution existed for independent businesses, or even small to medium size chains.</p>\\n<p>So, we chose to create a customer purchase and ordering platform for independent restaurants and bars:</p>\\n<p>Onboarding businesses had to be as streamlined as possible, so we created a simple sign-up form, followed by a drag-and-drop web interface for the owner to create their menu. Each menu has a unique QR code for the owner to display e.g. on tables. The owner can log back in at any time to update prices or availability of menu items, which will be instantly reflected in the menu the customer sees.</p>\\n<p>The customer scans the QR (or enters the menu ID on our website) and is taken directly to a mobile-optimized webapp where they can see what's on offer and add items to their basket. The customer can then submit their order and pay through PayPal - performing the entire transaction without downloading an app or creating an account!</p>\\n<p>Once confirmed, the order goes straight through to a touchscreen (which could be a cheap android tablet) in the kitchen/bar for staff to fulfill. Staff can tap the screen to check orders off once they're completed and keep track of the status.</p>\\n<h3>Advantages</h3>\\n<ul>\\n<li>The customer receives their order without leaving their seat!</li>\\n<li>Restaurant can reduce front of house staff</li>\\n<li>Bar can reduce average wait time</li>\\n<li>Front of house staff can focus on what really matters - providing an exceptional customer experience</li>\\n</ul>\\n<h2>The Tech</h2>\\n<p>The frontend of the app was written in Node.js and Express. We used these technologies since we all had experience with them - for this project we decided we should focus on delivering a great product, and there was still plenty to learn since we were new to the Azure platform.</p>\\n<p>We got Azure credit as part of the competition, so it made sense to use Microsoft's platform to host our Node app - we also used an MSSQL database and Azure Redis for caching. I quite enjoyed using Azure - it's becoming difficult to see the differentiation between GCP, AWS, and Azure for basic hosting like this. I think to choose between platforms I'd probably consider pricing first, and for simplicity go with the platform on which I was already using less common functionality like AWS Lambda.</p>\\n<h2>The UK finals</h2>\\n<p>We submitted a short video pitch and our business plan. After a couple of weeks we got a very exciting email: we were through to the UK finals! The final took place at Microsoft's London offices, where we were given the opportunity to present to such dignitaries as the CTO of Microsoft Accelerator, their Principal Tech Evangelist, and the Director of Azure for Research.</p>\\n<p>It was an amazing day, with sessions on entrepreneurship and tons of advice on how to start and scale a business. We got great feedback on our product - the judges highlighted our customer focus and real potential to disrupt the hospitality industry. Unfortunately we didn't make it through to the next stage of the competition, but I had a great time working with Wilson and Sam, and we all learned a lot technically, as well as about creating a startup.</p>\\n<p>Some feedback from the judges:</p>\\n<ul>\\n<li>\\\"Could definitely see this taking off\\\"</li>\\n<li>\\\"Slick presentation\\\"</li>\\n<li>\\\"You've clearly identified and addressed a real problem in this market\\\"</li>\\n<li>\\\"Solid validation from external stakeholders\\\"</li>\\n</ul>\",\"id\":\"/Users/matt/Documents/code/gatsby-blog-starter-kit/src/pages/2017-05-02-imagine/index.md absPath of file >>> MarkdownRemark\",\"fileAbsolutePath\":\"/Users/matt/Documents/code/gatsby-blog-starter-kit/src/pages/2017-05-02-imagine/index.md\",\"timeToRead\":3,\"frontmatter\":{\"date\":\"2017-05-02T11:27:49+01:00\",\"path\":\"/imagine\",\"tags\":[\"hackathon\",\"javascript\"],\"title\":\"Imagine\",\"summary\":\"Competing in the Microsoft Imagine Cup\"}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/bifurcate.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/bifurcate.json\n// module chunks = 23"],"sourceRoot":""}